INTRO:
shell –ø–æ–¥–¥—ä—Ä–∂–∞ globbing pattern (wildcards):
? - –µ–¥–∏–Ω –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω —Å–∏–º–≤–æ–ª
* - –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –±—Ä–æ–π –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–∏ —Å–∏–º–≤–æ–ª–∏
[abc] - —Ç–æ—á–Ω–æ —Ç–µ–∑–∏ —Å–∏–º–≤–æ–ª–∏ –≤ —Å–∫–æ–±–∏—Ç–µ
{fname1, fname2, ...}


ls -> –æ—Ç–ø–µ—á–∞—Ç–≤–∞ —Å–ø–∏—Å—ä–∫ —Å –≤—Å–∏—á–∫–∏ –æ–±–µ–∫—Ç–∏ –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
-l  : long listing format
-a : all including if it starts with .
-d : directory
-f : file
-i : inode
-x : list in lines not columns
-t : sort by time newest
-s : sort by size
ls -d /home/*/     -> vs dir v home

realpath (/home/st/‚Ä¶./f) , basename (f)

id -u           -> user number
id -g           -> group number
touch <name>

mkdir <–∏–º–µ> - —Å—ä–∑–¥–∞–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è

mkdir -p <–ø—ä—Ç> - —Å—ä–∑–¥–∞–≤–∞ –∏ –≤—Å–∏—á–∫–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø–æ –ø—ä—Ç—è

cp <–æ—Ç> <–¥–æ> - –∫–æ–ø–∏—Ä–∞ —Ñ–∞–π–ª

cp -r <–æ—Ç> <–¥–æ> - –∫–æ–ø–∏—Ä–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è

mv <–æ—Ç> <–¥–æ> - –ø—Ä–µ–∏–º–µ–Ω—É–≤–∞/–ø—Ä–µ–º–µ—Å—Ç–≤–∞ —Ñ–∞–π–ª

rm <–ø—ä—Ç> - –∏–∑—Ç—Ä–∏–≤–∞ —Ñ–∞–π–ª

rmdir <–ø—ä—Ç> - –∏–∑—Ç—Ä–∏–≤–∞ –ø—Ä–∞–∑–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è

rm -r <–ø—ä—Ç> - –∏–∑—Ç—Ä–∏–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –≤—Å–∏—á–∫–æ –≤ –Ω–µ—è

date - –∫–∞–∑–≤–∞ —Ç–µ–∫—É—â–æ—Ç–æ –≤—Ä–µ–º–µ
-r : last modification time
%a (Sun) , %A (Sunday), %b (Jan), %B (January), %C (century) , %d (day ot month 1-31), %H (0-23 hour), %I(01-12 hour), %j(day of year 1-366) , %m(month 1-12), %M (minutes 0-59),%n (new line), %s(seconds since 01/01/1970),%S(seconds),%p(am/pm), %u/%w(weekday 1-7/0-6),%y(last 2d of year)
date +'%Y-%m-%d  %H:%M:%S'
date -d "$line + 1 day" +'%Y-%m-%d'

stat - statistics
-c ‚Äúformat‚Äù file
%a/%A (perm bits octal/human), %F(file type),%g/%G(%u)(group id/name of owner), %h(num of hardlinks), %i(inode),%n(file name),%s(size in bytes),%w(file birth date),%x(last accessed),%y(last modified),%z(last status change)


find
+n , -n , n
-type f/d/l
-empty f/d
-amin,-mmin,-cmin,-atime (hours) -mtime n  // -mmin -60 last 60mins 
-gid,-group,-inum,-iname,-iregex ‚Äúpath‚Äù,-links (<>= n hl)
-name ‚Äúwildcard/glob‚Äù
-size [+,-,]n[c-bytes,k-kilo,M-mega,G-giga]
-perm -777 , -perm -u=r,g=wx,o=w    , -perm /u-w,g+r,o-w (user –∏ other –Ω—è–º–∞—Ç) 
-user ‚Äúname‚Äù
-printf : %m/M(perm), %An/Cn/Tn(last access/change/mod ‚Äò%Y-%M‚Äô‚Äô)  ,%n(hl),%p(name),%y(type)
‚Äú...‚Äù -o ‚Äú..‚Äù //or
-iname n, -name ‚Äú‚Äù,-group $(id -g), -uid,-mindepth
-newer
-executable
-L follow symlinks


chmod <> <path>
u=rwx,g=,o=
u[+,-]r
755 = 111(u), 101(g), 101(o)
-R recursive
umask -0022 kazva kvi sa


 ln <src> <dest> : hardlink , ln -s <s> <d> : symlink

df <f> (use % i tn, -h human readable, -i, -T (type))

glob
? -> 1
* -> 0+
[abc] -> a or b or c
[a-zA-Z0-9]*
[][!] -> [,],!
[!a-z] -> not a-z
[[?\] -> [,?,*,\
*.txt -> <neshto>.txt
‚Äò*.txt‚Äô -> tocho faila ‚Äú*.txt‚Äù

cat <f> , cat <f1> <f2> - pechata purvo celiq1 posle celiq2 //-n number row
echo ‚Äòsingle (‚Äò ‚Äú ‚Äò ‚Äú ‚Äò) double (‚Äú)‚Äô   //echo {f1,f2,f3}_{p1,p2,p3}

head -n 5 // -n -5 (bez poslednite 5) , -c 5 // za characters
tail -n 5 // -n +2 (bez purviq ,+1 e celiq fail, ‚Äúpochvai ot n-tiq red‚Äù)

xxd <f> // otmestvane | bytes | text -> red po red , pokazva go binaren ili hexa

file <f> //name | ‚Äúshell script‚Äù | ‚ÄúASCII‚Äù
tar -cf s.tar f1 f2 // s.tar e arhiv ot teq
tar -xf s.tar //razarhivira

gzip -k f result //kompresira , -k ne trie f
        -d res      //dekompresira

tar ‚Äìgzip -cf ‚Ä¶

echo -e ‚Äò1\n2\n3‚Äô

paste f1 f2 // line1.1 line2.1 \n line1.2 line 2.2 - kat kolonki , -d ‚Äòdelim‚Äô

wc 
-m (–±–∞–π—Ç–æ–≤–µ), -c (—Å–∏–º–≤–æ–ª–∏), -l (—Ä–µ–¥–æ–≤–µ), -w (–¥—É–º–∏)
wc smth/* -l     -> izvejda na vs filove lines i posle obshto za vsichkite sumirano


tr <zamenq tui>  <s tui>
-d ‚Äòdelete symbol‚Äô , -s ‚Äòsqueeze symbol‚Äô
tr ':' ' '     -> zamenq vs : s interval
tr a-z A-Z     -> zamenq vs malki s glavni bukvi

cut <tag> <kak> //izreji = dai mi ,	-d delim	-f fields		-c chars
-c 2 (izreji na vs red 2riq simvol) // -2(do vtoriq), 2-(sled vtoriq) , 2-5(2ri do 5ti) incl
-d ‚Äòdelim‚Äô -f [-n|n-|n-m|n,m,k] //nomer kolona


rev            -> reverses the string


sort //defolt za tekst
-n (chislovo) , -r (reverse), -h (za razmer MB,GB,..), -t ‚Äòdelim‚Äô , -k n,m (nomer koloni), -u (uniq)
uniq // trqq e sortiran, -c (izvejda br sreshtaniq predi da se merge-nat)

comm f1 f2 // samo v f1 , samo v f2 , obshti      - bachka sled sort
comm -1 -2 f1 f2  //maha 1 i 2 kolona => samo obshti

grep -E ‚Äòregex‚Äô   //escape -.\/?[]()*{}
-A 2 //namereniq i 2 sled nego (after) , -B 2 (analogichno before) , -C 2 (predi i sled po 2 context)
-i (case insensitive) , -v (vs bez namerenoto) , -o (samo namerenoto ne celiq red) , -q (bez izhod quiet)

regex 
. -> simvol sqkuv
^ -> nachalo na red , $ -> krai na red
[ab] -> a ili b
[a-zA-Z0-9]
[^a-z] -> da ne e a-z
‚Äòab|bc‚Äô -> ab ili bc
‚Äòok (ab|bc) ok‚Äô -> ‚Äòok ab ok‚Äô ili ‚Äòok bc ok‚Äô
()* -> 0+ , ()+ -> 1+ , (){4,8} -> mejdu 4 i 8
‚Äò([ab]).\1‚Äô -> axa , bxb

sed -E ‚Äòs/<regex>/<zamenq>/g‚Äô  // -i (edit in-place)
sed 's/./&\n/g'

who // s0600   pts/0  date hour addr
whoami // s0600



diff s1 s2 //ako sa ednakvi nishto ne se pechata (pechata difference)
diff -q s1 s2 //exit status 0, ako sa razlichni exit status >= 1 + info za razlikite
diff -s s1 s2 //result: Files s1 and s3 are identical


alias h=‚Äùsome commands‚Äù
h //result
unalias h

pwgen 10 4   //gives 4 random 0-9A-z with len 10



test ‚áî [[ smth ]]
-z ‚Äústr‚Äù  -> len = 0
-e (exists) , -f (file) , -d (dir) , -h (symlink) , -s (size > 0)
sravnenie na chisla:  -eq, -gt, -lt, -le, -ge
sravnenie na nizove:  ==, >, <, !=
[[. -ge . && . -le . ]]
[[ ! $1 =~ ^[a-zA-Z0-9]+$ ]] //=~ checks if the string on its left matches the regex
[[ ! ..  ]]  -> not
[[ ! $1 =~ ^[0-9]+$ ]] //not num

awk - –ø—Ä–∏–µ–º–∞ —Å–∫—Ä–∏–ø—Ç –Ω–∞–ø–∏—Å–∞–Ω –Ω–∞ –µ–∑–∏–∫–∞ awk –∏ –≥–æ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –≤—ä—Ä—Ö—É —Ç–µ–∫—Å—Ç–∞ –Ω–∞ stdin
awk -f <—Å–∫—Ä–∏–ø—Ç> —á–µ—Ç–µ awk —Å–∫—Ä–∏–ø—Ç –æ—Ç —Ñ–∞–π–ª –≤–º–µ—Å—Ç–æ –æ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç
awk —Å–∏ –µ –µ–∑–∏–∫ –∑–∞ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –∏ –∏–º–∞ BEGIN-END –µ–∫–≤–∏–≤–∞–ª–µ–Ω—Ç –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è/—Ü–∏–∫—ä–ª/if statement
awk '{ print $1 }' t.txt //printira 1vite koloni s delim ' ', samo print e kato kat
awk '{ print $NF }' t.txt //printira poslednata kolona na vseki red => NF dava br koloni na red (Number of fields)
awk -F ':' '{ print $1 }' t.txt //-F slaga nov delim
awk '{ print $1 $2 "->" $3 }'
awk -F '/' '{if ($(NF-1)=="0") {print $0}'
awk '{ sum += $0 } END {print sum/1024}'
awk -v var=${key} '{if ($1==var) print $0}'
awk -F ':' '{printf "%s,", $2}' 
awk '{for (i=3;i<=NF;i++) printf "%s ",$i}'
awk -F ',' '{printf "%s ", $1} {for (i=2;i<NF;i++) printf "%s,", $i} {printf "%s\n", $NF}'
awk -F '/' '{for (i=2;i<NF;i++) printf "%s/",$i}'
echo -e "apple\nbanana\ncherry" | awk '{print NR, $0}'  //number of row from 1 => she dade nomer na red na vs red : 1 apple\n 2 banana ...
awk 'NR==2' filename // print the 2nd line of a file  , FNR total rows
{ .. ; printf "%s-%s %s %s",array,drive,ct,mt ; ‚Ä¶ ; }


ps -e           ->   –∏–∑–ø–∏—Å–≤–∞ –¥–∞–Ω–Ω–∏ –∑–∞ –≤—Å–∏—á–∫–∏ –ø—Ä–æ—Ü–µ—Å–∏
ps -u <user>    ->   –∏–∑–ø–∏—Å–≤–∞ –¥–∞–Ω–Ω–∏ –∑–∞ –ø—Ä–æ—Ü–µ—Å–∏—Ç–µ –Ω–∞ –¥–∞–¥–µ–Ω–∏—è –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª //-g <group>
ps -f           ->   –∫–∞–∑–≤–∞ –Ω–∞ ps –¥–∞ –∏–∑–ø–∏—Å–≤–∞ –ø–æ–≤–µ—á–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
ps -ef          ->   –ø–æ–∫–∞–∑–≤–∞ –º–Ω–æ–≥–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –≤—Å–∏—á–∫–∏ –ø—Ä–æ—Ü–µ—Å–∏
ps -o           ->   –º–æ–∂–µ–º –¥–∞ –≤–∫–ª—é—á–∏–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∏ –∫–æ–ª–æ–Ω–∫–∏ –≤ –∏–∑—Ö–æ–¥–∞ –Ω–∞ ps
ps -u pesho -o pid,ppid,cmd   ->   –∑–∞ –≤—Å–µ–∫–∏ –ø—Ä–æ—Ü–µ—Å –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è pesho, –∏–∑–ø–∏—Å–≤–∞ –Ω–µ–≥–æ–≤–∏—è PID, —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏ PID –∏ –∫–æ–º–∞–Ω–¥a //-g za group
ps -e -o user=account, pid=process_id    ->   –ú–æ–∂–µ–º –¥–∞ –∏–º–µ–Ω—É–≤–∞–º–µ –∫–æ–ª–æ–Ω–∫–∏—Ç–µ
ps -e --sort=etimes -o cmd 
ps -e --sort=vsz  -o pid,cmd 
cpu, cmd, comm , pid ,  etimes (time since beginning), vsz/rsz (virtual/real size) 



xargs -I{} grep ':{}:' /etc/group
‚Äú $( some inner script ) ‚Äù

cm > f //vs otiva v f
cm 1> f , cm 2> f , cm &> f (mai e kat >) , cm < f (cat f e in na comm)

/dev/null

> prezapisva , >> dobavq nai-otdolu



‚Äî------------------------------------------------------------------------------------------------------------------------


SCRIPT

#!/bin/bash
${0}  ->  putq do skripta
${1}, ${2}, ...   -> dostup do parametrite
${#}  ->  broi parametri
${*}  ->  vsichki parametri: "${1} ${2} ${3}"
${@}  ->  vsichki parametri: "${1}" "${2}" "${3}"
${?}  ->  exit status na predishnata komanda
${!}  ->  PID // wait <pid>
${IFS}  -> delim

ako e v dvoini kavichki ${} se vijda , v edinichni ne
‚Äú${}‚Äù ok , ‚Äò${}‚Äô not ok

ako e bez $ polzva obekta, s $ polzwa stoinostta

read name
echo "Hello, ${name}"

read a b
echo "${a} + ${b} equals $((a+b))"
$(( <aritmetichen izraz> ))
bc  -> priema ot stdin i pak smqta aritmetichni izrazi

max=${currentCount}
currentCount=$(( currentCount + 1 ))

arr[i]=$j
userName=${arr[${choice}]}

KATO SUZDAVASH PROMENLIVI TR SA DOLEPENI DO RAVNOTO, KATO PRAISH KOMANDI TR DA SA RAZDELENI

tmp=$( mktemp )   or tmpdir=$( mktemp -d )  // rm $tmp    or   rm -r $tmp at end of file
find ~ -type f -printf '%TY-%Tm-%Td %p\n' | sort | cut -d' ' -f1 > $tmp

read -a arr <<< "Hello World" // -a array: arr[0]=Hello , arr[1]=World
read -d ":" var <<< "Hello:World" // -d delim : vzema samo var=Hello
read -n 3 var <<< "Hello World" // -n nchars : var=Hel
read -p "Enter your name: " name // -p prompt

shift , shift n //shift n args
Before shift operation: arg1 arg2 arg3
After shift operation: arg2 arg3 //${1}=arg2

{ <cmd 1> ; <cmd 2> ; }  -> tuk se promenqt neshtata
( <cmd 1> ; <cmd 2> ; )  -> tuk e drug shell i pravi kopie i vutre ne pravi realni promeni

[[ <logicheski izraz> ]]  ->  vrushta 0 ili 1 ‚áî test

((count++))
mn=$n
sleep n //program freeze for n sec
exit 0 -> ok  ,  exit >0 -> not ok
—Ä–∞–Ω–¥—ä–º —á–∏—Å–ª–æ –µ —Å $(( (RANDOM % b) + a  )), –∫–æ–µ—Ç–æ —â–µ –≥–µ–Ω–µ—Ä–∏—Ä–∞ —á–∏—Å–ª–æ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ [a, b]



‚Äî----------------------

array:

declare -a arr=("apple" "banana" "cherry")
arr+=("date")
for i in "${my_array[@]}" // "$i" == "banana"

map:

declare - A arr
arr["abv2"] = 1
[[ -z ${ arr["$ans"] } ]] => arr["$ans"] = 2
arr[index]=${line}

obhojdane:

//s ! minava prez indeksite , bez ! prez elementite => za map s ! e za value , bez ! e za key
for i in "${!arr[@]}" // "$i -> ${arr[$i]}"

‚Äî----------------------



‚Äî------------------------------------------------------------------------------------------------------------------------
sintaksis:

‚Äî----------------------
if <komanda>
then
   <deistvie>
else //elif
   <dr neshto>
fi


‚Äî----------------------
for <promenliva> in <masiv ot argumenti razdelen s interval> 
do
  <deistvie>
done


for i in "${@}" ;...
for i in $( seq 1 10 )
for (( i=0; i<5; i++ ))

------------------------

while read line   //while read col1 col2 res_cols   //while true , break, continue
do
       
done < <( pipes )

‚Äî----------------------



function <ime> {
     //funkciite si polzvat ${0} i drte takiva za argumentite s koito sa izvikani
     //suzdavame promenlivi vutre s local :   local smth = "${1}"
}


‚Äî----------------------















NA PETIO LAINATA üòµ‚Äçüí´
env variables
${0} script path
${1} do n parametri
${#} broi parametri
${@} vsi4ki parametri pootdelno
${*} vsi4ki parametri concatenirano
${?} exit status na posl komanda
${!} PID
@{IFS} razdelitel na parametrite po default whitespace
//–§–æ—Ä–º–∞—Ç–∏—Ä–∞–Ω–µ –∏ –∏–∑–≤–µ–∂–¥–∞–Ω–µ
cat [-n]
cut [-f(ield) -d(elimiter) (—Ä–∞–±–æ—Ç—è—Ç –∫–∞—Ç–æ –ø—Ä–∏ —Å–æ—Ä—Ç) -c num1-num2 (ot char na pos num1 do char na pos num2)] 
head [-n(um lines, –∞–∫–æ –µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª–Ω–æ –µ –±–µ–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ n) -c(hars)]
sort [-n(umerical) -r(everse) -k {—á–∏—Å–ª–æ} (–ø–æ –∫–æ—è –∫–æ–ª–æ–Ω–∞, –∫–æ–º–±–∏–Ω–∏—Ä–∞ —Å–µ —Å t, –∑–∞ –¥–∞ –æ–ø—Ä–µ–¥–µ–ª–∏ –∫–æ–ª–æ–Ω–∏—Ç–µ) -t(delimiter) -u(nique)]
tail [-n(um lines, –∞–∫–æ –µ —Å + —á–∏—Å–ª–æ—Ç–æ –æ—Ç–ø—Ä–µ–¥ –µ –±–µ–∑ –ø—ä—Ä–≤–∏—Ç–µ n-1) -c(hars)]
tr [-d] —Ç–≤–∞ –µ replace <–∫–æ–µ> <—Å –∫–æ–µ> [—Å d —Ç—Ä–∏–µ –≤—Å —Å—Ä–µ—â–∞–Ω–∏—è –∏ –Ω—è–º–∞ <—Å –∫–æ–µ>]
uniq [-c(ount)] 
wc [-l -m -c -w] number of [lines char bytes words] in format [lines file]

//–û–ø–µ—Ä–∞—Ü–∏–∏ —Å —Ñ–∞–π–ª–æ–≤–µ –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
basename —Å–∞–º–æ –∏–º–µ—Ç–æ
cp [-r] <–æ—Ç> <–¥–æ> –∫–æ–ø–∏—Ä–∞ [–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è]
df file space usage
dirname —Å–∞–º–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞
du [-a(ll)] df ama za direktorii
find [
-user $id
-type f d l (file directory symlink)
-size +-40[c,k,M,G] more/less than 40 b,kb,mb,gb
-exec (smmth) {} \; // exec test ! -e {} \ -print; –≤—Å–∏—á–∫–∏ —Å—á—É–ø–µ–Ω–∏ –ª–∏–Ω–∫–æ–≤–µ —Å —Ç–æ–≤–∞
-delete —Ç—Ä–∏–µ –≤—Å–∏—á–∫–∏ –º–∞—á–æ–≤–µ
-readable with read perm
-mindepth 
-maxdepth 
-name 
-iname ".*" –≤—Å–∏—á–∫–∏ –≤–∏–¥–∏–º–∏ —Ñ–∞–π–ª–æ–≤–µ
-perm <perms> (exact match) / -g=w (all that have g w) / /222 (writable)
-print 
-printf
	%m - permissions
	%f file base name
	%A@ last access to file in unix
	%C@ status change
	%d file depth
	%g group name
	%G group id
	%i inode num
	%1 na koe e symlink (nqma nishto ako ne e)
	%n number of hard links
	%p path
	%s size
	%T@ last modification in unix (imashe go na dosta mesta tva)
	%u user name
	%U userId
	%Y
-executable –∫–∞—Ç–æ readable
 -inum —Å—ä—Å inode nomer ...]
ln [-s] <–¥–æ> <–æ—Ç> –°—ä–∑–¥–∞–≤–∞ [sym]–ª–∏–Ω–∫
mkdir [-p] —Å—ä–∑–¥–∞–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è [—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ]
mv
readlink
rm [-f(orce) -v(erbose)]
stat [-c(format)] - info za file
	%a perm (oct)
	%A perm
	%F type
	%g gid
	%G gName
	%h num of hardlinks
	%i inode num
	%n file namme
	%s size bytes
	%u uid
	%U uName
	%w time of creation
	%x time of last access
	%y time of last mod
	%z time of last status change
	–í–†–ï–ú–ï–ù–ê–¢–ê –° –ì–õ–ê–í–ù–ò –ë–£–ö–í–ò –°–ê –í unix timestamp –∏–ª–∏ –∫–∞–∫—Ç–æ —Å–∞ –Ω–∞—Ä–∏—á–∞ –∞–±–µ —á–∏—Å–ª–∞ —Å–∞
touch —Å—ä–∑–¥–∞–≤–∞ —Ñ–∞–π–ª

//–û–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø—Ä–æ—Ü–µ—Å–∏
kill pid/ killall uid
ps [-e(very) -o(user defined format, naprimer pid,ppid,tid,stat,euid,pgrp,cmd....) -u(ser, matchva euid) -g(roup) -sort <po kakvo>]

//–ü—Ä–∞–≤–∞ –∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏
chmod u=r / 435 / u+x / u-x / +x / -x (default e 777 dir 666 file
chown ownr:grp <file>
id [-u]
whoami

//–°–ø–µ—Ü–∏–∞–ª–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏
awk [-F(split by separator) -v(–∑–∞ —Å–ª–∞–≥–∞–Ω–µ –Ω–∞ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ var=val)]
	NR number of rows
	NF number of fields
	awk '/regex/ {print}'
	printf '%s', $i –ø—Ä–∏–Ω—Ç–≤–∞ –∏-—Ç–∏—è —Ñ–∏–µ–ª–¥
bc —Å—ä–±–∏—Ä–∞ —á–∏—Å–ª–∞, –∏–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∫–∞—Ç–æ –º—É —Å–µ –ø–æ–¥–∞–≤–∞—Ç —Ñ–∞–π–ª–æ–≤–µ —Å —á–∏—Å–ª–∞ —Å pipe
date [-u(tc) -d(from date) +<format>] 
exec 
grep [-e(za regex) -q(uiet) -o(–≤—Ä—ä—â–∞ —Å–∞–º–∏—è –º–∞—á –∞ –Ω–µ —Ü–µ–ª–∏—è —Ä–µ–¥) -v(invert patter) -F(ixed string) -f(ile)]
mkpasswd
pwgen
printf [—à–∏–±–∞–Ω —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–Ω–∏—è –ª—Ç—Ñ]
sed [-E(regex) -i(nplace)]
	—Ñ–æ—Ä–º–∞—Ç–∞ –µ s/–æ—Ç/–¥–æ/g –∏ –ø—Ä–∞–≤–∏ —Ä–µ–ø–ª–µ–π—Å
sha256sum –≤–∞–¥–∏ –≥–æ –≤—ä–≤ —Ñ–æ—Ä–º–∞—Ç —Ö–µ—à —Ñ–∞–π–ª–Ω–µ–π–º
tar [-x(tract) -f(ile –≤–∏–Ω–∞–≥–∏ –ø–æ—Å–ª) -t(list archive) -c(reate)]
xargs [-I<–ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞>] -> xargs -I{} (smth) {} ({} –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –≤—Å–∏—á–∫–æ, –Ω–µ –µ –Ω—É–∂–Ω–æ –¥–∞ —Å–µ –∫–∞–∑–≤–∞ —Ç–∞–∫–∞, –Ω–æ —Ç–æ–≤–∞ –µ –∫–æ–Ω–≤–µ–Ω—Ü–∏—è—Ç–∞)
xxd binary file content

//–°–ø–µ—Ü–∏–∞–ª–Ω–æ –∑–∞ —Å–∫—Ä–∏–ø—Ç–æ–≤–µ –∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏
echo [-n(o new line)]
exit
read [-p] –ß–µ—Ç–µ [with prompt]
test

//Syntax
if [[ ! -[f,d,r,w,x,e,h,z] ${file} ]] - if file is not [file,directory,readable,writable,executable,exist,symbolic link,empty]
declare -A arr - arr where string can be index; if [[ ! -v arr[index] ]] ; then ‚Äì arr[index] not declared
if [[ "$EUID" -ne 0 ]] - if user not root

if [[ uslovie ]] then .... else .... elif .... fi
while [[uslovie]]/read var/true do .... done /<<(<comanda>)
for i in ${file} do ... done
comparisons -eq -gt -lt -le -ge / == > < != (za string) / =~ za regex / ako sled [[ ima ! e otricanie



